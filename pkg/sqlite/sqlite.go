package sqlite

import (
	"context"
	"database/sql"
	"embed"
	"fmt"
	"io/fs"
	"sort"
	"time"

	"github.com/dhenkes/gofman/pkg/gofman"
	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3"
)

//go:embed migration/*.sql
var migrationFS embed.FS

// DB represents a database connection to our application.
type DB struct {
	db     *sql.DB
	ctx    context.Context
	cancel func()

	// Datasource name. Is automatically generated by calling NewDB() or SetDSN()
	DSN string

	// Returns a new ID. Defaults to a UUID v4.
	ID func() (string, error)

	// Returns the current time as a unix timestamp.
	Now func() int64

	// AuthService is required to generate passwords, tokens and verify password
	// hashes
	AuthService gofman.AuthService
}

// NewDB returns a new instance of DB.
func NewDB() *DB {
	db := &DB{
		ID:  id,
		Now: now,
	}

	db.ctx, db.cancel = context.WithCancel(context.Background())

	return db
}

// Open opens the database connection.
func (db *DB) Open() (err error) {
	if db.DSN == "" {
		return gofman.NewError(gofman.EINVALID, "DSN required.")
	}

	if db.db, err = sql.Open("sqlite3", db.DSN); err != nil {
		return err
	}

	if _, err := db.db.Exec(`PRAGMA journal_mode = wal;`); err != nil {
		return gofman.NewError(gofman.EINTERNAL, "Could not enable wal: %v", err)
	}

	if _, err := db.db.Exec(`PRAGMA foreign_keys = ON;`); err != nil {
		return gofman.NewError(gofman.EINTERNAL, "Could not enable foreign keys: %v", err)
	}

	if err := db.migrate(); err != nil {
		return err
	}

	return nil
}

// migrate runs all non-executed migration files from the sqlite/migration
// folder.
func (db *DB) migrate() error {
	_, err := db.db.Exec(`CREATE TABLE IF NOT EXISTS migrations (name TEXT PRIMARY KEY);`)
	if err != nil {
		return gofman.NewError(gofman.EINTERNAL, "Could not create migrations table: %v", err)
	}

	names, err := fs.Glob(migrationFS, "migration/*.sql")
	if err != nil {
		return err
	}

	sort.Strings(names)

	for _, name := range names {
		if err := db.migrateFile(name); err != nil {
			return gofman.NewError(gofman.EINTERNAL, "Error during migration in %q: %v", name, err)
		}
	}

	return nil
}

// migrateFile takes a migration file name and executes it's content.
func (db *DB) migrateFile(name string) error {
	tx, err := db.db.Begin()
	if err != nil {
		return err
	}

	defer tx.Rollback()

	var n int

	err = tx.QueryRow(`SELECT COUNT(*) FROM migrations WHERE name = ?`, name).Scan(&n)
	if err != nil {
		return err
	}

	if n != 0 {
		return nil
	}

	if buf, err := fs.ReadFile(migrationFS, name); err != nil {
		return err
	} else if _, err := tx.Exec(string(buf)); err != nil {
		return err
	}

	if _, err := tx.Exec(`INSERT INTO migrations (name) VALUES (?)`, name); err != nil {
		return err
	}

	return tx.Commit()
}

// Close closes the database connection.
func (db *DB) Close() error {
	db.cancel()

	if db.db != nil {
		return db.db.Close()
	}

	return nil
}

// Tx wraps the SQL Tx object to provide a timestamp at the start of the transaction.
type Tx struct {
	*sql.Tx
	db  *DB
	now int64
}

// BeginTx starts a transaction and returns a wrapper Tx type.
func (db *DB) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	tx, err := db.db.BeginTx(ctx, opts)
	if err != nil {
		return nil, err
	}

	return &Tx{
		Tx:  tx,
		db:  db,
		now: now(),
	}, nil
}

// id is a helper function returning a new UUID v4.
func id() (string, error) {
	var err error

	defer func() {
		if recover() != nil {
			err = gofman.NewError(gofman.EINTERNAL, "Could not generate UUID.")
		}
	}()

	id := uuid.NewString()

	return id, err
}

// now is a helper function returning the current unix timestamp.
func now() int64 {
	return time.Now().Unix()
}

// formatLimitOffset returns a SQL string for a given limit & offset.
func formatLimitOffset(limit, offset int) string {
	if limit > 0 && offset > 0 {
		return fmt.Sprintf(`LIMIT %d OFFSET %d`, limit, offset)
	}

	if limit > 0 {
		return fmt.Sprintf(`LIMIT %d`, limit)
	}

	if offset > 0 {
		return fmt.Sprintf(`OFFSET %d`, offset)
	}

	return ""
}
